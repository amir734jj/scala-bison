-- A (typed) tree language for Cool abstract syntax trees

module COOL[] begin
  type Symbol;
  type Boolean;

  phylum Program;

  phylum Class_;
  phylum Classes := SEQUENCE[Class_];

  phylum Feature;
  phylum Features := SEQUENCE[Feature];

  phylum Formal;
  phylum Formals := SEQUENCE[Formal];

  phylum Expression;
  phylum Expressions := SEQUENCE[Expression];

  phylum Case;
  phylum Cases := SEQUENCE[Case];

  constructor program(classes : Classes) : Program;
  constructor class_(name : Symbol; parent: Symbol; 
	             features : Features; filename : Symbol): Class_;

  -- Features:
  constructor method(overridep : Boolean;
                     name : Symbol;
		     formals : Formals;
		     return_type : Symbol;
		     expr : Expression) : Feature;
  constructor attr(name, of_type : Symbol) : Feature;

  -- Formals
  constructor formal(name, of_type: Symbol) : Formal;

  -- Case
  constructor branch(name, of_type: Symbol; expr: Expression): Case;

  -- Expressions
  constructor assign(name : Symbol; expr : Expression) : Expression;
  constructor static_dispatch(expr: Expression; 
                              type_name : Symbol;                              
                              name : Symbol; 
                              actuals : Expressions) : Expression;
  constructor dispatch(expr : Expression; 
		       name : Symbol;
		       actuals : Expressions) : Expression;
  constructor cond(pred, then_exp, else_exp : Expression): Expression;
  constructor loop(pred, body: Expression) : Expression;
  constructor typcase(expr: Expression; cases: Cases): Expression;
  constructor block(body: Expressions) : Expression;
  constructor let(identifier, of_type: Symbol; 
		  init, body: Expression): Expression;
  constructor  add(e1, e2: Expression) : Expression;
  constructor  sub(e1, e2: Expression) : Expression;
  constructor  mul(e1, e2: Expression) : Expression;
  constructor  div(e1, e2: Expression) : Expression;
  constructor  neg(e1: Expression) : Expression;
  constructor  eql(e1, e2: Expression) : Expression;
  constructor   lt(e1, e2: Expression) : Expression;
  constructor  leq(e1, e2: Expression) : Expression;
  constructor comp(e1: Expression) : Expression;
  constructor int_const(token: Symbol) : Expression;
  constructor bool_const(value: Boolean) : Expression;
  constructor string_const(token: Symbol) : Expression;
  constructor new_(type_name: Symbol): Expression;
  constructor unit(): Expression;
  constructor no_expr(): Expression;  
  constructor variable(name: Symbol): Expression;
end;
