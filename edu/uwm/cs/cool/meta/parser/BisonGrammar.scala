/* LALR(1) Parser generation for Scala
 * John Boyland
 * This file may be used, copied and/or modified for any purpose.
 */
package edu.uwm.cs.cool.meta.parser;

import scala.collection.mutable.Map;
import scala.collection.mutable.ArrayBuffer;
import scala.collection.mutable.HashMap;

class BisonGrammar() extends Grammar {
  val special : Nonterminal = add(new ArtificialNonterminal("$accept",""));
  val error : Nonterminal = add(new ErrorNonterminal);

  var prologue : String = "/* Generated by Scala-Bison version "+Version.version+" */\n";
  var extra : String = "";

  def addExtra(x : String) = { extra = x; }

  def addPrologue(x : List[Code]) = {
    // Can't get this to work:
    // prologue = (prologue /: x)(+)
    for (c <- x) {
      prologue += (c toString);
    }
  }

  def setStart(sym : Nonterminal) = { 
    _start = sym;
    rules += new Rule(0,special,start :: end :: Nil,null,NoCode());
  }

  def addRule(new_rule : Rule) = {
    if (_start == null) setStart(new_rule.lhs);
    rules += new_rule;
  }
  
  override def add[T <: Symbol](name : T) : T = super.add(name)

  def getNT(name : String) : Nonterminal = {
    get(name) match {
      case x:Nonterminal => x
      case _ => throw new GrammarSpecificationError("Not a nonterminal: " + name);
    }
  }

  def getCLT(ch : Char) : Terminal = {
    val name : String = "'" + ch + "'";
    find(name) match {
      case Some(t:Terminal) => t
      case None => add(new CharLitTerminal(ch));
    }
  }

}

